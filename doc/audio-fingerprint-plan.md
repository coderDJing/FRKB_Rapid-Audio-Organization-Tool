# 音频内容哈希（当前策略）与声纹后备方案

## 背景
- 当前策略：对解码后的 PCM 样本（标准化参数）计算 SHA256“音频内容哈希”，从而忽略封装/元数据差异。
- 目标是开箱即用：无需用户安装 FFmpeg 或外部库，默认不启用 Chromaprint。

## 目标
- 以“音频内容哈希”作为唯一标识：相同内容 → 相同哈希；不同编码/容器但内容变化 → 可能不同哈希。
- 声纹（Chromaprint）路径保留为后备方案，但默认关闭。

## 当前实现概述
- **音频内容哈希**：读取文件 → 用 Symphonia 解码为 PCM → 统一标准化（当前实现为 16-bit i16、交错样本；采样率/声道按源流）→ 将 PCM 字节流喂入 SHA256，得到“内容哈希”。
- **结果输出（Rust → Node）**：仅输出三字段：`sha256_hash`（内容哈希）、`file_path`、`error`。
- **开发模式**：在 `mainWindow` 中，通过 `is.dev` 打印每首歌曲的分析结果并跳过后续指纹库/持久化流程；生产模式才执行完整流程。

## 依赖说明
- 当前仅依赖 `symphonia` 解码与 `ring` 的 SHA256；无 Chromaprint/FFmpeg 运行时依赖。

### 质量标签
- 已从当前输出中移除（前端未用）。如后续需要再恢复。

### 并发与性能
- 采用 Rayon 并行处理；PCM 哈希对整首音频做流式处理，内存占用可控。

### 错误处理与日志
- 内容哈希失败时仅返回 `error` 字段，不影响其他文件处理。

## 后续工作建议
- 如需跨格式更鲁棒的“同曲”识别，可评估继续使用 Chromaprint 或自研峰值哈希方案（STFT + 峰对）。
- 若恢复质量标签，请在 Rust 端与类型声明同步添加相应字段。

