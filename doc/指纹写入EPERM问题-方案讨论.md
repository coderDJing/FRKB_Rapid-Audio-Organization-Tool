### 指纹写入 EPERM 问题 · 最终方案

本方案确定采用“多版本 JSON + 指针文件 latest.meta”的方式，彻底规避覆盖被占用文件带来的 EPERM 风险；不隐藏指纹文件；在任何读取之前执行一次性“去隐藏并建立指针”的修复流程；跨平台采用保守重试并忽略 ENOSPC（由导入前置校验兜底）。

---

### 1. 背景
- 线上偶发错误：在 Windows 环境，写入 `D:\FRKB_database\songFingerprint\songFingerprintV2.json` 时出现 `EPERM: operation not permitted, open ...`，导致指纹写入失败。
- 当前实现存在多处写入路径，且部分未 `await`，部分路径使用 `operateHiddenFile` 切换隐藏属性、部分未使用，易出现竞态与占用冲突。
- 需要一个稳定、可维护的长期方案，避免数据损坏与用户侧体验问题。

### 2. 现状与关键路径
- 指纹库落盘点（节选）：
  - `src/main/window/mainWindow.ts`：直接 `fs.outputJSON(...)`（存在未 `await` 情况）。
  - `src/main/index.ts`：初始化 / 导入 / 清空时写入，部分经 `operateHiddenFile`。
  - `src/main/cloudSync.ts`：云同步完成后本地替换（期望原子）。
- 隐藏属性处理：`src/main/utils.ts` 的 `operateHiddenFile()` 通过 `attrib -h/+h` 切换隐藏属性；但并非所有写路径统一经此入口。

### 3. 问题研判（可能成因）
- 并发写入竞争：多个 IPC 或流程同时写同一文件，Windows 下更易触发 `EPERM/EBUSY`。
- 未 `await` 的异步写入：新写入在上一次尚未完成时发起，放大竞争与锁冲突。
- 非原子覆盖：直接覆盖目标文件，遇到杀毒/索引器/同步盘短暂占用即失败。
- 隐藏属性竞态：部分路径切隐藏、部分未切，状态不一致导致更多冲突。
- 环境因素：磁盘满（ENOSPC）、网络盘/同步盘抖动、企业安全策略/UAC、第二实例占用等。

### 4. 目标
- 消除 `EPERM` 类失败的主因，确保高成功率与数据一致性。
- 落盘具备幂等性与可恢复性，杜绝“半写入/损坏”。
- 对用户“无感”，不改变现有 UI 与使用路径。

### 5. 多版本 JSON + 指针（最终选型）
- 核心思路：
  - 单点串行：建立 `FingerprintStore` 模块集中管理指纹读写，进程内互斥，所有写入统一走一个出口并 `await`。
  - 不覆盖旧文件：每次写“新版本文件”，再原子切换 `latest.meta` 指向新版本，杜绝覆盖被占用文件。
  - 重试与退避：对 `EPERM/EBUSY/UNKNOWN` 等进行指数退避（50/100/200/400/800ms，最多 3–5 次，可配置）。
  - 限流合并：`debounce` 200–500ms，合并高频更新，减少落盘次数。
  - 不隐藏文件：不再切换隐藏位，消除因隐藏属性变化触发的占用/锁冲突。
  - 清理旧版本：后台保留最近 N=5 个版本，其余静默删除（失败下次再试）。
- 对外接口（示意）：
  - `load(): Promise<string[]>`
  - `save(list: string[]): Promise<void>`
  - `appendMany(list: string[]): Promise<{ added: number }>`
  - `export(toPath: string): Promise<void>` / `import(fromPath: string): Promise<{ added: number }>`
  - `getCount(): number`
- 改造点：
  - 替换 `mainWindow.ts`、`index.ts`、`cloudSync.ts` 中的所有写入为 `FingerprintStore.save/appendMany`，并保证全部 `await`。
  - 取消对指纹文件的 `operateHiddenFile` 混用，或统一到单点内。
- 收益：改造量小，快速稳定；对现有渲染层无感；足以覆盖当前问题的 90%+。

### 6. 启动前置修复流程（在读取指纹文件之前执行）
- 目标：一次性修理旧版本可能“隐藏”的 `songFingerprintV2.json`，并确保后续不再切换隐藏位；修复必须发生在任何读取指纹文件之前。
- 触发：仅 Windows 且未存在修复标记文件（如 `.fingerprint_healed`）时执行；幂等可重试。
- 步骤：
  1) 确保目录存在：`FRKB_database/songFingerprint`，不存在则创建。
  2) 若存在 `songFingerprintV2.json`：
     - 读取/检测是否隐藏（`attrib "<file>"` 包含 `H`）。
     - 若隐藏：执行 `attrib -h "<file>"` 去隐藏（带指数退避重试：50/100/200/400/800ms）。
     - 读取内容用于生成第一个“版本文件”；然后原子写入 `latest.meta` 指向该版本。
  3) 若不存在 `songFingerprintV2.json`：创建空数组 `[]`，直接原子写入。
  4) 落标记：写入 `.fingerprint_healed`，表示修复完成。
- 时序要求：必须在任何 `load()`/读取指纹列表之前调用，例如在主进程启动早期（读取 `store.songFingerprintList` 之前）。
- 并发：修复时对外部写入排队；完成后再放行后续落盘。
- 日志：仅连续失败记录一次错误摘要；重试成功不记日志（属预期类瞬时占用）。

### 7. 跨平台错误码与重试策略
- 目标：兼顾 Win / macOS / Linux 差异，既确保成功率又避免无谓重试。
- 可重试集合（建议）：
  - Windows：`EPERM` / `EBUSY` / `EACCES` / `UNKNOWN`
    - 说明：Windows 下短暂占用或安全策略导致的 `EPERM/EACCES` 具有一定“瞬时”特征，先行少次重试更稳妥。
  - macOS / Linux：`EBUSY` / `EAGAIN` / `UNKNOWN`
    - 说明：`EPERM/EACCES` 更多为“权限类永久错误”，默认不重试（或最多 1 次快速复验）。
- 不重试集合（各平台一致）：
  - `ENOENT`（路径不存在）、`ENOTDIR/EISDIR`（路径类型错误）、`EROFS`（只读文件系统）、`EXDEV`（跨设备移动）等。
  - `ENOSPC`（磁盘空间不足）忽略：由导入链路提前拦截与提示。
- 重试算法（建议默认值）：
  - 最大尝试：5 次（含首次）
  - 退避序列：50ms → 100ms → 200ms → 400ms → 800ms（可加入 ±25% 抖动）
  - Windows 上的 `EACCES`：最多 2 次，避免权限问题长时间无效重试
  - 总时限：单次写入总耗时上限 ~3s，超出则视为失败
  - debounce：300ms（合并高频更新，可调）

### 8. 风险与缓解
- 杀毒/索引器/同步盘占用 → 原子替换 + 重试退避 + 限流减少触发窗口。
- 并发写入 → 单点串行互斥；渲染层仅通过 IPC 调主进程写入。
- 数据损坏/半写入 → 临时文件 + 原子覆盖 + `.bak` 备份 + 加载回退。
- ABI/构建风险（方案 B） → 统一 `electron-rebuild`，锁定依赖版本，CI 预编译校验。
- 日志噪音 → 仅记录“非预期错误”；预期类（如短暂占用）重试成功后不落日志，连续失败才告警。

### 9. 开放问题（需确认）
- 指纹文件是否必须隐藏？若必须，在哪些场景/目录政策下需要？
- 方案 A 是否足以覆盖近中期需求？是否需要规划 B 的时间窗口？
- 云同步完成后的本地合并是否需要强校验（计数或采样校验）？
- 失败告警阈值：连续 N 次重试失败后是否提示用户？提示方式？

### 10. 实施计划（建议）
- 阶段 1（0.5 天）：落地 `FingerprintStore` 单点写入（原子写、重试、限流、备份/回退），接入并替换所有调用点，全部 `await`，统一隐藏策略。
- 阶段 2（0.5 天）：联调导入/导出/云同步链路，做基本压力与边界测试（杀毒/索引器开启、磁盘紧张、同步盘目录）。
- 阶段 3（可选，2–3 天）：封装 DB 访问层（better-sqlite3），实现无感迁移器，灰度开关，完成回归测试。

### 11. 验收标准
- 连续 1,000 次追加指纹批量写入不出现 `EPERM/EBUSY` 失败（或重试后均成功、无用户可感知失败）。
- 模拟杀毒/索引/同步盘占用场景，最终落盘成功率 ≥ 99.9%，且无文件损坏。
- 导入/导出/云同步链路保持原有行为与性能目标；出现 ENOSPC 等明确环境问题时，提示清晰可理解。

### 12. 监控与排查
- 在单点写入处埋点：来源、耗时、重试次数、结果；仅对连续失败落日志。
- 发生失败时自动收集：是否使用隐藏属性、是否存在并发队列、当前防毒/索引器状态（可选提示）。

### 13. 相关代码位置（便于改造）
- `src/main/window/mainWindow.ts`（指纹分析落盘）
- `src/main/index.ts`（初始化/导入/清空）
- `src/main/cloudSync.ts`（本地原子替换）
- `src/main/utils.ts`（`operateHiddenFile` 实现）

---

### 附：决策建议
- 已确定采用“多版本 JSON + 指针”方案；不再引入数据库迁移方案。

### 决策清单（逐项确认）
- 1) 存储路线
  - [x] A：JSON 工程化（单点串行 + 原子写 + 重试 + 限流 + 统一隐藏）
    - 选择原因：
      - 指纹条目约 1万–10万，启动时一次性加载内存可接受
      - 写入仅在导入后发生，频率不高，且只有新增/清空两类操作
      - 通过“原子写 + 重试退避 + 全量 await + 轻量限流”即可规避 EPERM 主因，改动最小
- 2) 隐藏策略
  - [x] 不隐藏文件
- 3) 旧版本一次性修复策略
  - [x] 策略A：去隐藏文件 → 原子重写 → 写入修复标记（且在首次读取之前执行）
- 4) 写入实现参数（建议默认值，可再确认）
  - 平台化可重试集合：
    - Windows：EPERM / EBUSY / EACCES / UNKNOWN
    - macOS/Linux：EBUSY / EAGAIN / UNKNOWN（EPERM/EACCES 默认不重试或最多 1 次复验）
  - 退避：50/100/200/400/800ms（5 次，±25% 抖动）
  - debounce：300ms
  - 原子写：同目录 `*.tmp` → `move(overwrite)`
  - await：所有写入必须 await，错误集中捕获

### 14. 重试失败与不可重试时的处理流程
- 目标：在无法成功落盘时保证“用户可继续使用、数据不丢、后续能恢复”。
- 流程：
  1) 重试仍失败（可重试类）：
     - 保持内存态数据为最新（用户本次导入结果仍生效）。
     - 入队延时重试任务（如 2s/5s/10s 递增），后台静默重试；成功则清队列。
     - 若连续失败达阈值（如 3 轮），弹一次非阻断提示：建议将数据库目录加入杀毒/索引器白名单或避免放入同步盘；提供“一键复制目录路径”。
     - 记录一次摘要日志（错误码/重试次数/耗时）。
  2) 不可重试类（ENOSPC/EROFS/路径结构错误等）：
     - 立即失败并提示明确原因与操作建议：
       - ENOSPC：提示清理磁盘或更换数据库目录；可提供“打开目录”按钮。
       - EROFS：提示当前目录只读，建议迁移数据库目录。
       - ENOTDIR/EISDIR：路径结构异常，建议“恢复默认结构”或引导手动修复。
     - 不中断应用使用，保留内存态数据；允许用户稍后手动“重试落盘”。
  3) 退出前尝试：
     - 在退出钩子中做一次限时（如 ≤1s）的落盘尝试；避免长时间卡住退出。
  4) 观测：
     - 重试成功不记日志；仅在连续失败时记录一次摘要，避免日志噪音。


