## 场景与症状

在“移动/删除歌曲”后，当前列表再次排序或筛选，已被移走/删除的歌曲在 UI 中“复活”，双击后出现“文件未找到”。

---

## 根因总结（面向快速定位）

- 事件落地不一致：不同入口（对话框移动、列表拖拽、右键删除、播放器移动/删除、导出后删除）未统一广播或统一处理，导致当前视图的 `originalSongInfoArr` 未被及时剔除。
- 路径匹配不一致：大小写/斜杠混用导致比对失败（'\\' vs '/'、`C:` vs `c:`），判定“无交集”，从而不剔除。
- 双路径/竞态：本地即时重建与全局事件重建并行，时序打架；或排序/筛选基于旧 `originalSongInfoArr` 直接拷贝重建。

---

## 现行机制（避免“复活”的关键点）

- 统一真源：始终以 `originalSongInfoArr` 为源，通过 `applyFiltersAndSorting()` 重建显示。
- 全局剔除：`onSongsRemoved` 不再依赖 `listUUID`，仅要与当前 `originalSongInfoArr` 有交集即剔除并 `applyFiltersAndSorting()`。
- 路径规范化：所有 `songsRemoved` 事件发出前，路径统一 `toLowerCase()` + 斜杠归一（'/'→'\\'）；接收端按规范化集合求交集。
- 对话框即时同步：`songsArea.vue` 在移动确认后，先基于快照本地剔除并 `applyFiltersAndSorting()`，消除小窗口竞态。
- 排序/筛选唯一入口：列头点击仅更新列 `order`，随后统一调用 `applyFiltersAndSorting()`；末尾按 `filePath` 去重。

涉及文件（主要入口）
- `src/renderer/src/pages/modules/songsArea/songsArea.vue`
- `src/renderer/src/pages/modules/songsArea/composables/useSongsAreaEvents.ts`
- `src/renderer/src/pages/modules/songsArea/composables/useSongsAreaColumns.ts`
- `src/renderer/src/pages/modules/songsArea/composables/useSelectAndMoveSongs.ts`
- `src/renderer/src/pages/modules/songsArea/composables/useDragSongs.ts`
- `src/renderer/src/pages/modules/songPlayer/usePlayerControlsLogic.ts`

---

## 最快检查清单（5 步定位）

1) 操作路径确认：本次“移动/删除”是通过哪条入口（对话框/拖拽/右键/播放器/导出后删除）？
2) 事件是否广播：对应入口是否发出了 `emitter.emit('songsRemoved', { listUUID, paths })`？paths 是否已规范化（小写/反斜杠）？
3) 交集判断是否命中：`onSongsRemoved` 是否对当前 `originalSongInfoArr` 产生交集并执行剔除？
4) 列表是否统一重建：是否通过 `applyFiltersAndSorting()` 重建（而非直接复制旧数组排序/筛选）？
5) 二次操作稳定性：紧接着多次排序/筛选，`originalSongInfoArr.length` 与 `runtime.songsArea.songInfoArr.length` 是否一致并稳定下降？

---

## 关键代码与应急检查点（建议临时加日志，排查后删除）

1) 全局事件接收：`useSongsAreaEvents.ts` → `onSongsRemoved`
```ts
// 仅示例：临时打印交集与前后长度（加后请记得删除）
const beforeLen = originalSongInfoArr.value.length
const norm = (p?: string|null) => (p||'').replace(/\//g,'\\').toLowerCase()
const set = new Set((payload as any).paths.map((p:string)=>norm(p)))
const interCount = originalSongInfoArr.value.filter(s=>set.has(norm(s.filePath))).length
console.log('[Troubleshoot] onSongsRemoved', { beforeLen, interCount })
// ...剔除+applyFiltersAndSorting 后：
console.log('[Troubleshoot] onSongsRemoved', { afterLen: originalSongInfoArr.value.length })
```

2) 对话框移动确认：`songsArea.vue` → `onMoveSongsDialogConfirmed`
```ts
console.log('[Troubleshoot] moveDialog', {
  fromList: runtime.songsArea.songListUUID,
  removed: runtime.songsArea.selectedSongFilePath.length
})
```

3) 拖拽移动：`useDragSongs.ts` → `handleDropToSongList`
```ts
console.log('[Troubleshoot] dragMove emit songsRemoved', {
  sourceList: runtime.songsArea.songListUUID,
  count: selectedSongFilePaths.length
})
```

4) 播放器移动/删除：`usePlayerControlsLogic.ts`（移动或删除处）
```ts
console.log('[Troubleshoot] player emit songsRemoved', {
  list: runtime.playingData.playingSongListUUID,
  file: filePathToMove || filePathToDelete
})
```

> 注意：上述日志仅在自测/排查时临时加入；问题解决后务必删除，避免污染。

---

## 排查流程（决策树简版）

- 看入口：对话框/拖拽/右键/播放器/导出后删除 → 对应代码是否广播了 `songsRemoved`（且路径已规范化）？
- 看接收：`onSongsRemoved` 是否命中交集 → 若未命中，检查路径大小写/斜杠与 `listUUID` 是否错误依赖。
- 看重建：是否统一走 `applyFiltersAndSorting()` → 若存在任何直接基于旧数组的排序/筛选，移除之。
- 看稳定性：排序/筛选后长度与样本路径是否与预期一致 → 若不一致，检查是否存在第二条“本地即时重建”与全局事件的竞争窗口，按“对话框即时同步”方式收敛到单一路径。

---

## 防退建议

- 在新增“移动/删除”入口时：
  - 必须广播 `songsRemoved`，并规范化 `paths`。
  - 不直接改显示列表，统一交给 `onSongsRemoved` + `applyFiltersAndSorting()`。
- 在修改排序/筛选时：
  - 严禁直接对显示列表做拷贝排序；仅更新列配置后调用 `applyFiltersAndSorting()`。
- 在播放器链路中：
  - 删除/移动使用“操作开始时”的列表 UUID 快照作为事件的 `listUUID`。

---

## 完整回归建议（简）

- 分别通过：对话框移动、列表拖拽、右键删除、播放器移动/删除、导出后删除 → 执行一次“移动/删除→立即排序/筛选”，均不应“复活”。
- 双击播放链路无 ENOENT；如有，结合最近一次事件确认该路径是否已被剔除。

---

## 附：一键核对点（代码级）

- `useSongsAreaEvents.ts` → `onSongsRemoved`：不依赖 `listUUID`，使用规范化路径求交集并剔除后 `applyFiltersAndSorting()`。
- `useSongsAreaColumns.ts` → `applyFiltersAndSorting`：末尾按 `filePath` 去重；排序/筛选不触碰 `originalSongInfoArr`。
- `useSelectAndMoveSongs.ts` / `useDragSongs.ts` / `useSongItemContextMenu.ts` / `usePlayerControlsLogic.ts`：发出 `songsRemoved` 前完成路径规范化。
- `songsArea.vue` → `onMoveSongsDialogConfirmed`：对话框移动后本地即时剔除 + 统一重建（仅此一处允许本地即时剔除）。

---

（全文为面向维护者的快速排查指引；若需线上排查，可按“关键代码与应急检查点”章节临时加入日志，定位后请务必清理。）