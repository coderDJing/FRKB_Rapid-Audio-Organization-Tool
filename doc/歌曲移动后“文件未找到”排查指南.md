## 场景

在“移动歌曲到其他歌单”后，当前歌单列表发生变化，偶尔出现点击第一首歌时提示“文件未找到”。该歌曲实为此前删除/移动的项，在界面上“复活”。

## 根因分析（总结）
- 事件监听位置不当：`songsRemoved` 仅在拖拽回调内部临时注册，很多删除/移动路径（右键菜单、播放器错误删除、对话框移动）触发的全局事件未被当前页面接收，导致 `originalSongInfoArr` 没有同步删除，后续按原始数据重建/排序时被“复活”。
- 重复请求的竞态：双击时直接 `send('readSongFile')`，而播放器也会在 `playingSong` 变化后发送一次，导致两个不同 `requestId` 的读文件请求交错，叠加上面监听缺失，放大偶现问题。
- 小 bug：一次 `filter` 调用缺少谓词，可能造成状态不同步（已修）。

## 最快检查清单（下次再现时优先看这个）
- 【操作流确认】是否是“移动到其他歌单后，立即点击列头排序才复现”。
- 【事件是否到位】移动完成后，是否收到一次 `songsRemoved`（带 `listUUID`）。
- 【排序是否统一】列头点击后是否调用了 `applyFiltersAndSorting()`（而不是直接基于旧 `originalSongInfoArr` 重建）。
- 【数据一致性】`originalSongInfoArr` 长度变化是否和显示列表重算后长度一致；被移走的 `filePath` 是否不再出现在两者中。
- 【播放链路】双击后仅触发一次加载；不存在 ENOENT 同时缺少对应 `songsRemoved` 的情况。

## 修复要点（本次已实现）
1. 将 `songsRemoved` 全局事件监听移动到 `songsArea.vue` 组件挂载时注册，卸载时注销，避免漏听与重复注册。
2. 将 `songsMovedByDrag` 同样在挂载/卸载时一次性注册/注销，并移除其内部嵌套的 `songsRemoved` 监听。
3. 在 `songDblClick` 中移除直接 `send('readSongFile')`，只设置 `playingSong`，统一由播放器的监听来发起加载，消除竞态。
4. 修复 `selectedSongFilePath.filter()` 缺少谓词的问题。
5. 取消在 `onMoveSongsDialogConfirmed` 中对本地 `originalSongInfoArr`/`songInfoArr` 的直接过滤与重排，完全交给全局事件（`songsRemoved` 等）驱动更新，避免双路径更新时序打架引起“复活”。

### 本轮补充修复（已提交）
- 列头排序：`colMenuClick` 改为仅更新列的 `order`，随后统一调用 `applyFiltersAndSorting()` 重建显示，杜绝直接基于旧 `originalSongInfoArr` 的拷贝排序导致“复活”。
- 删除键路径：删除后只更新 `originalSongInfoArr`，再调用 `applyFiltersAndSorting()`，不再手动拼装显示列表。
- 移动对话框确认：`useSelectAndMoveSongs.ts` 移除对本地显示列表的直接过滤，只清空选择并广播 `songsRemoved`。
- 拖拽/右键删除事件：更新 `originalSongInfoArr` 后统一调用 `applyFiltersAndSorting()`，保持与排序和筛选一致的单一真源。

涉及文件：
- `src/renderer/src/pages/modules/songsArea/songsArea.vue`
- `src/renderer/src/pages/modules/songsArea/composables/useSelectAndMoveSongs.ts`

## 如何再次遇到问题时收集信息
- 优先提供持久化日志 `log.txt` 的“最小片段”（无需整份）：
  - 日志位置：
    - 正式打包：`C:\\Users\\<你的用户名>\\AppData\\Roaming\\<应用名>\\log.txt`
    - 开发模式：主进程 `userDataDir\\log.txt`
  - 关键行关键词（任选匹配包含上下各几十行）：
    - `[SongsArea] OPEN_LIST_START` / `OPEN_LIST_DONE` / `LIST_UUID_CHANGED` / `LIST_CLEARED`
    - `[SongsArea] EVENT_songsRemoved` / `EVENT_songsMovedByDrag` / `CONTEXT_MENU_REMOVE` / `MOVE_DIALOG_CONFIRMED` / `DELETE_KEY`
    - `[SongsArea] SORT`
    - `[SongsArea] DBLCLICK`
    - `[SongsArea] SYNC_PLAYING_LIST`
    - `[Player] NEXT` / `PREVIOUS` / `DELETE_NEXT` / `MOVE_NEXT`
    - `[Player] READ_MAIN_OK` / `READ_MAIN_ERR` / `READ_MAIN_IGNORED`
    - `[Player] READ_PRELOAD_OK` / `READ_PRELOAD_ERR`
  - 我需要看到：
    - 你“移动/删除/排序/切换歌单”到“出现报错/点击播放”的连续日志片段。
    - 每条日志里自带 uuid、数量与必要标识（不会有整列表内容，避免超大日志）。

### 临时调试片段（可复制，排查后请删除）
- 在 `songsArea.vue` 中为 `applyFiltersAndSorting()`、`onSongsRemoved()`、`colMenuClick()` 加一次性日志：

```ts
// 1) applyFiltersAndSorting 开头与结尾：
console.log('[SongsArea] APPLY_START', {
  originalLen: originalSongInfoArr.value.length,
  sortedCol: columnData.value.find((c) => c.order)?.key
})

// ...原函数体...

console.log('[SongsArea] APPLY_DONE', {
  runtimeLen: runtime.songsArea.songInfoArr.length,
  example: runtime.songsArea.songInfoArr.slice(0, 3).map(s => s.filePath)
})

// 2) onSongsRemoved：
console.log('[SongsArea] EVENT_songsRemoved', {
  listUUID: (payload as any).listUUID,
  removeCount: Array.isArray((payload as any).paths) ? (payload as any).paths.length : 0
})

// 3) 列头点击（排序）：
console.log('[SongsArea] SORT', {
  key: col.key,
  newOrder: newColumnData.find((c) => c.key === col.key)?.order
})
```

- 在 `useSelectAndMoveSongs.ts` 的 `handleMoveSongsConfirm` 末尾，确认仅广播事件、不再直接改显示列表：

```ts
console.log('[SongsArea] MOVE_DIALOG_CONFIRMED', {
  fromList: runtime.songsArea.songListUUID,
  moved: selectedPaths.length
})
```

提示：上述日志仅用于现场定位，问题解决后请删除，避免污染正式日志。

- 若无法提供 `log.txt`，可退而截取“开发者工具 → Console”的关键片段：
  - 是否有 `emitter.emit('songsRemoved', ...)` 的调用、双击后是否只触发一次 `readSongFile`。
  - 列表重建/排序前后 `originalSongInfoArr` 与 `songInfoArr` 的长度差异。
- 描述操作序列：
  - 从哪个歌单移动到哪个歌单？使用了哪种方式（拖拽/对话框/右键）？
  - 移动后是否立即切换过歌单或排序？是否立即双击？
  - 点击时报错的行号（第一首/中间）和报错前后 UI 是否闪动重排。

## 若仍偶现的进一步方向
- 在 `openSongList()`、排序变更、`songsRemoved` 处理等关键点增加一次性调试日志（文件路径集合的差集），确认不存在“基于旧 original 重建”的链路。
- 检查其它发出 `songsRemoved` 的路径是否都包含 `listUUID`，或确保未提供 `listUUID` 时也能落到当前歌单更新（当前实现已兼容）。
- 若用户快速连续操作（移动→立即双击），可考虑在移动完成后对当前歌单显示区加一个极短的“忙碌状态”以抵御竞态。

### 日志对照提示（实战）
- 在“移动/删除”后，优先期待：
  - 出现 `MOVE_DIALOG_CONFIRMED`（仅记录操作完成，不做本地重建）。
  - 随后出现 `EVENT_songsRemoved ... original X->Y runtime A->B`，两者数量变化一致；不应再看到本地重建引起的“X->X 或 A->A”。
- 双击后：
  - 若歌曲确已被移除，应不会再看到该歌曲的 `DBLCLICK`；若仍双击到了旧项，检查其前后是否缺少对应的 `EVENT_songsRemoved` 或者列表未及时刷新。
  - 出现 `READ_MAIN_ERR ENOENT` 时，结合最近一次 `EVENT_songsRemoved`，核对该曲目是否在移除集合中；如是，则表明 UI 残留旧数据，需聚焦该歌单的事件传播与渲染刷新链路（目前已通过取消本地重建收窄窗口）。

## 变更影响
- 列表删除/移动的同步性更强，不再“复活”。
- 双击播放不再重复发送读文件请求，播放链路更稳定。

## 当前状态与清理情况
- 现状：该问题在近期版本中已无法复现。
- 已执行清理：
  - 移除了排查期临时持久化日志，包括 `persistLog` 及其所有调用。
  - 删除了 `@renderer/utils/debugFlags` 的导入与对应文件，`ENABLE_TROUBLESHOOT_LOGS` 常量已下线。
  - 未动主进程通用错误日志与渲染层全局错误捕获功能。

## 如需重新排查时的回滚指引（仅当问题再现时）
- 在需要时，可临时恢复以下能力以便定位：
  - 在相关页面内局部增加一次性日志（建议直接使用 `console.log` 或临时 IPC 写入），关键点参考“若仍偶现的进一步方向”一节。
  - 可临时新增一个调试开关文件（名称自定，例如 `debugFlags.local.ts`），避免再次污染主分支；问题解决后务必删除。
- 建议仅在自测分支启用上述回滚措施，避免发布版本带上冗余日志。

## 验证
- 构建运行后，重复此前可疑操作流，`log.txt` 中不应再出现 `"[SongsArea]"` / `"[Player]"` 等排查前缀日志；功能正常。

