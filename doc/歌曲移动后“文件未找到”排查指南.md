## 场景

在“移动歌曲到其他歌单”后，当前歌单列表发生变化，偶尔出现点击第一首歌时提示“文件未找到”。该歌曲实为此前删除/移动的项，在界面上“复活”。

## 根因分析（总结）
- 事件监听位置不当：`songsRemoved` 仅在拖拽回调内部临时注册，很多删除/移动路径（右键菜单、播放器错误删除、对话框移动）触发的全局事件未被当前页面接收，导致 `originalSongInfoArr` 没有同步删除，后续按原始数据重建/排序时被“复活”。
- 重复请求的竞态：双击时直接 `send('readSongFile')`，而播放器也会在 `playingSong` 变化后发送一次，导致两个不同 `requestId` 的读文件请求交错，叠加上面监听缺失，放大偶现问题。
- 小 bug：一次 `filter` 调用缺少谓词，可能造成状态不同步（已修）。

## 修复要点（本次已实现）
1. 将 `songsRemoved` 全局事件监听移动到 `songsArea.vue` 组件挂载时注册，卸载时注销，避免漏听与重复注册。
2. 将 `songsMovedByDrag` 同样在挂载/卸载时一次性注册/注销，并移除其内部嵌套的 `songsRemoved` 监听。
3. 在 `songDblClick` 中移除直接 `send('readSongFile')`，只设置 `playingSong`，统一由播放器的监听来发起加载，消除竞态。
4. 修复 `selectedSongFilePath.filter()` 缺少谓词的问题。

涉及文件：
- `src/renderer/src/pages/modules/songsArea/songsArea.vue`

## 如何再次遇到问题时收集信息
- 打开“开发者工具 → Console”，截取以下日志片段：
  - 触发移动/删除时是否打印了 `emitter.emit('songsRemoved', ...)` 的调用方日志（播放器错误删除、右键菜单、拖拽、对话框确认）。
  - 列表重建/排序前后 `originalSongInfoArr` 与 `songInfoArr` 的长度差异（如有需要可临时加入 `console.debug`）。
  - 双击播放后是否只有一条 `readSongFile` 发送日志（应只来自播放器 watch 逻辑）。
- 描述操作序列：
  - 从哪个歌单移动到哪个歌单？使用了哪种方式（拖拽/对话框/右键）？
  - 移动后是否立即切换过歌单或排序？
  - 点击时报错位置的行号（第一首/列表中间）和报错前后 UI 是否闪动重排。

## 若仍偶现的进一步方向
- 在 `openSongList()`、排序变更、`songsRemoved` 处理等关键点增加一次性调试日志（文件路径集合的差集），确认不存在“基于旧 original 重建”的链路。
- 检查其它发出 `songsRemoved` 的路径是否都包含 `listUUID`，或确保未提供 `listUUID` 时也能落到当前歌单更新（当前实现已兼容）。
- 若用户快速连续操作（移动→立即双击），可考虑在移动完成后对当前歌单显示区加一个极短的“忙碌状态”以抵御竞态。

## 变更影响
- 列表删除/移动的同步性更强，不再“复活”。
- 双击播放不再重复发送读文件请求，播放链路更稳定。

