/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface SelectionFailed {
  errorCode: string
  message?: string
}
export interface TrainSelectionGbdtResult {
  status: string
  modelRevision?: number
  modelPath?: string
  failed?: SelectionFailed
}
export interface PredictSelectionItem {
  id: string
  score: number
}
export interface PredictSelectionCandidatesResult {
  status: string
  modelRevision?: number
  items?: Array<PredictSelectionItem>
  failed?: SelectionFailed
}
export interface SelectionFeatureStatusItem {
  songId: string
  hasFeatures: boolean
}
export interface UpsertSongFeaturesInput {
  songId: string
  fileHash: string
  modelVersion: string
  openl3Vector?: Buffer
  chromaprintFingerprint?: string
  rmsMean?: number
  hpcp?: Buffer
  bpm?: number
  key?: string
  durationSec?: number
  bitrateKbps?: number
}
export interface SetSelectionLabelsResult {
  total: number
  changed: number
  sampleChangeCount: number
  sampleChangeDelta: number
}
export interface SelectionLabelSnapshot {
  positiveIds: Array<string>
  negativeIds: Array<string>
  sampleChangeCount: number
}
export interface SelectionPathIndexEntry {
  pathKey: string
  filePath: string
  size: number
  mtimeMs: number
  songId: string
  fileHash: string
  updatedAt: number
  lastSeenAt: number
}
export interface UpsertSelectionPathIndexEntry {
  pathKey: string
  filePath: string
  size: number
  mtimeMs: number
  songId: string
  fileHash: string
}
export interface SelectionPathIndexGcOptions {
  ttlDays?: number
  maxRows?: number
  deleteLimit?: number
  minIntervalMs?: number
}
export interface SelectionPathIndexGcResult {
  skipped: boolean
  before: number
  after: number
  deletedOld: number
  deletedOverflow: number
  lastGcAt: number
}
export declare function upsertSongFeatures(featureStorePath: string, items: Array<UpsertSongFeaturesInput>): number
export declare function extractOpenL3Embedding(filePath: string, maxSeconds?: number | undefined | null, maxWindows?: number | undefined | null): Promise<Buffer>
export declare function setSelectionLabels(labelStorePath: string, songIds: Array<string>, label: string): SetSelectionLabelsResult
export declare function getSelectionLabelSnapshot(labelStorePath: string): SelectionLabelSnapshot
export declare function resetSelectionSampleChangeCount(labelStorePath: string): number
export declare function resetSelectionLabels(labelStorePath: string): boolean
export declare function getSelectionFeatureStatus(featureStorePath: string, songIds: Array<string>): Array<SelectionFeatureStatusItem>
export declare function getSelectionPathIndexEntries(pathIndexStorePath: string, pathKeys: Array<string>): Array<SelectionPathIndexEntry>
export declare function upsertSelectionPathIndexEntries(pathIndexStorePath: string, items: Array<UpsertSelectionPathIndexEntry>): number
export declare function touchSelectionPathIndexEntries(pathIndexStorePath: string, pathKeys: Array<string>): number
export declare function deleteSelectionPathIndexEntries(pathIndexStorePath: string, pathKeys: Array<string>): number
export declare function gcSelectionPathIndex(pathIndexStorePath: string, options?: SelectionPathIndexGcOptions | undefined | null): SelectionPathIndexGcResult
export declare function getSelectionLabel(labelStorePath: string, songId: string): string
export declare function bumpSelectionSampleChangeCount(labelStorePath: string, delta: number): number
export declare function deleteSelectionPredictionCache(featureStorePath: string, songIds: Array<string>): number
export declare function clearSelectionPredictionCache(featureStorePath: string): number
export declare function trainSelectionGbdt(positiveIds: Array<string>, negativeIds: Array<string>, featureStorePath: string): TrainSelectionGbdtResult
export declare function predictSelectionCandidates(candidateIds: Array<string>, featureStorePath: string, modelPath?: string | undefined | null, topK?: number | undefined | null): PredictSelectionCandidatesResult
/** 进度信息结构体 */
export interface ProcessProgress {
  processed: number
  total: number
}
/** 音频文件处理结果 */
export interface AudioFileResult {
  /** 整个文件的 SHA256（当前为标准化 PCM 内容哈希），用于去重 */
  sha256Hash: string
  /** 原始文件路径 */
  filePath: string
  /** 错误描述（当分析失败时） */
  error?: string
}
/** 音频解码结果 */
export interface DecodeAudioResult {
  /** PCM 数据（Buffer，内部为 f32 小端序，需在 JS 侧转为 Float32Array） */
  pcmData: Buffer
  /** 采样率 */
  sampleRate: number
  /** 声道数 */
  channels: number
  /** 总帧数 */
  totalFrames: number
  /** 错误描述（当解码失败时） */
  error?: string
}
/**
 * 计算音频文件的 SHA256 哈希值，并生成声纹与质量标签
 *
 * # 参数
 * * `file_paths` - 音频文件路径数组
 *
 * # 返回值
 * * 包含每个文件哈希值和路径的结果数组
 */
export declare function calculateAudioHashes(filePaths: Array<string>): Array<AudioFileResult>
/** 带进度回调的异步音频处理 */
export declare function calculateAudioHashesWithProgress(filePaths: Array<string>, callback?: (err: Error | null, arg: ProcessProgress) => any | undefined | null): Promise<Array<AudioFileResult>>
/** 计算整文件 SHA256（不解码，速度快；与 PCM 内容哈希互不兼容） */
export declare function calculateFileHashes(filePaths: Array<string>): Array<AudioFileResult>
/** 计算整文件 SHA256（带进度） */
export declare function calculateFileHashesWithProgress(filePaths: Array<string>, callback?: (err: Error | null, arg: ProcessProgress) => any | undefined | null): Promise<Array<AudioFileResult>>
/**
 * 解码音频文件为 PCM Float32Array
 *
 * # 参数
 * * `file_path` - 音频文件路径
 *
 * # 返回值
 * * 包含 PCM 数据和元数据的解码结果
 */
export declare function decodeAudioFile(filePath: string): DecodeAudioResult
/**
 * 解码音频文件为 PCM Float32Array（限长，避免大文件阻塞与占用内存）
 *
 * - `max_seconds <= 0` 时不限制长度
 * - 返回的 `totalFrames` 为**本次返回的 PCM 帧数**（非整曲）
 */
export declare function decodeAudioFileLimited(filePath: string, maxSeconds: number): Promise<DecodeAudioResult>
